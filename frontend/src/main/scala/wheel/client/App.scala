/*package wheel.client

import com.raquo.laminar.api.L.*
import wheel.api.ServiceRPC  // Generated by Airframe plugin (run sbt frontend/compile first)
import org.scalajs.dom
import wvlet.airframe.http.Http

object App {
  def main(args: Array[String]): Unit = {
    renderOnDomContentLoaded(
      dom.document.getElementById("app"),
      appElement()
    )
  }

  def appElement(): Element = {
    val nameVar = Var("World")  // Reactive variable
    val greetingSignal = nameVar.signal  // Signal for reactivity

    val rpcClient = ServiceRPC.newRPCAsyncClient(Http.client.newAsyncClient("http://localhost:8080"))  // Airframe RPC client

    div(
      h1("Hello Laminar + Airframe RPC!"),
      input(
        `type` := "text",
        placeholder := "Enter name",
        onInput.mapToValue --> nameVar
      ),
      button(
        "Greet",
        onClick --> { _ =>
          rpcClient.Greeter.greet(nameVar.now()).run { response =>
            dom.window.alert(response)  // Display RPC response
          }
        }
      ),
      p(child.text <-- greetingSignal.map(name => s"Current name: $name"))  // Reactive update
    )  }
}
*/
package wheel.client

import wheel.api.ServiceRPC
import org.scalajs.dom
import org.scalajs.dom.html
import wvlet.airframe.http.Http
import wvlet.log.LogSupport
import wvlet.airframe.rx.{Cancelable, OnCompletion, OnError, OnNext, RxEvent}

object App extends LogSupport {
  def main(args: Array[String]): Unit = {
    // Enable debug logging for Airframe
    wvlet.log.Logger.setDefaultLogLevel(wvlet.log.LogLevel.DEBUG)

    // Create a button
    val button = dom.document.createElement("button").asInstanceOf[html.Button]
    button.textContent = "Test Greet API"
    dom.document.getElementById("app").appendChild(button)

    // Create RPC client
    val rpcClient = ServiceRPC.newRPCAsyncClient(Http.client.newAsyncClient("http://localhost:8080"))

    // Handle button click
    button.onclick = { _ =>
      info("Sending greet request for name: Test")
      val a = rpcClient.Greeter.greet("Test") /*.run { response =>
        info(s"Received response: $response")
        dom.console.log(s"API Response: $response")
      }*/
      println( a )
      a.run { event =>
        println("event")
        println(event)
        //event match {
         //  case OnNext(value) => println(value)// Handle the successful value (e.g., println(value) or store it)
        //  case OnError(error) => println(error)// Handle any exception (e.g., throw error or log it)
          // case OnCompletion => println("aa")// Optional: Handle stream completion (useful for multi-value Rx)
        //}
        // Cancelable.empty // Return a Cancelable (use Cancelable.empty if no cancellation needed)
      }
    }
  }
}
